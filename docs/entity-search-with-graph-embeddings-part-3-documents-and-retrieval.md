# 使用图形嵌入的实体搜索-第 3 部分-文档和检索

> 原文：<https://web.archive.org/web/sease.io/2019/12/entity-search-with-graph-embeddings-part-3-documents-and-retrieval.html>

在这篇文章中，我们想要了解虚拟文档创建过程的核心。正如我们在[第 1 部分](https://web.archive.org/web/20220930003904/https://sease.io/2019/11/entity-search-with-graph-embeddings---part-1---overview.html)中解释的，这些文档对于检索阶段及其性能是必不可少的。管道的这一部分实际上是我们在许多不同版本中创建自己的方法的部分。

简要总结前面说明的内容。在[第 2 部分](https://web.archive.org/web/20220930003904/https://sease.io/?p=2210)中，我们已经看到了如何从 RDF 三元组获得实体嵌入，以及如何在聚类过程中使用它们。在这个阶段的最后，我们获得了几组高度相关和相似的实体。

在这篇文章中，**我们将描述项目管道的第二部分:文档创建、排名系统、**和**实体检索**。

![](img/f1ee50ecdbbf763e008b8f546e0ca8db.png)

## 虚拟文档创建

一旦获得聚类，我们就可以创建所有这些虚拟文档，它们将成为我们检索阶段的集合。为了做到这一点，我们的方法关联到每个语义领域，由一个集群，一个文件。详细来说，**流程**由五个阶段组成:

1.  1.  选择一个群集；
    2.  一个接一个地取集群实体；
    3.  对于每个实体，我们选择相应的 RDF 三元组(那些将该实体作为主语或宾语的三元组)；
    4.  对三元组进行处理，通过去除“”、“”、“_”等符号，获得自然语言中的信息。
    5.  将信息合并到一个文本文件中，该文件表示与手边的群集相关联的文档。

T2T4

然后，对每个集群重复整个过程，获得我们的文档集合。

![This image has an empty alt attribute; its file name is Document_process.png](img/39b6fe21e5e99132b690b7f00c5e825a.png)

## 分级制

感谢前一阶段，我们现在有一个文件的集合，这是一个集群的集合。现在，我们将实现检索，以便为每个用户查询(也称为主题)获得聚类的排序列表。这一阶段的目的是确定哪些语义场(簇)与用户的信息需求更相关。在下一阶段，我们将对这些字段中的实体进行重新排序。

对于检索，我们通过使用 Terrier 软件应用了经典的文本检索技术。这是一个用 Java 编写的开源搜索引擎，由格拉斯哥大学开发。它实现了最先进的索引和检索功能，为开发和评估大规模检索应用程序提供了一个平台。

对于我们使用的文档的排名:

*   *   在索引阶段:停用词去除和词干提取；
    *   在回收阶段:BM25 型号。

【T8

在这个检索阶段之后，我们获得一个排序的聚类列表。看到这个结果，有人可能会说，用户想要的是实体的排序列表。这是下一阶段的目标:从这些集群中提取与用户更相关的实体。

## 实体检索

对于实体检索，我们实现了两种不同的方法:**组合系统**和**融合系统**。第一个目的是获得实体的**排序列表**，直接从属于前一阶段的排序列表的那些集群中选择它们。第二种方法旨在利用最先进的方法和组合系统获得相同的结果。

###### 组合系统

我们为实体检索实现的第一种方法由三个不同的版本组成。具体而言，它们是:

1.  1.  **SICO**
    2.  相扑
    3.  **WECO**

为了更好地理解实体检索过程，我们首先要给出主要思想的概述，然后再详细介绍该过程。

**想法**:想法是从聚类的排序列表的前 k 个聚类中提取前 j 个实体，然后将它们合并到最终运行中。

如何从前 k 个簇中提取前 j 个实体？我们决定使用[第一部分](https://web.archive.org/web/20220930003904/https://sease.io/2019/11/entity-search-with-graph-embeddings---part-1---overview.html)中描述的最先进的方法。特别是，我们将我们感兴趣的小世界限制在集群级别。这样，我们就有了一个包含集群中所有实体的数据集。我们创建的集合由文档组成，其中每个文档代表集群中的一个实体。和最先进的一样，我们将为每个实体准备一个文档。显然，这是为每个集群完成的，为每个集群获取一个集合。

这组集合(每个集群一个)是在实体检索过程开始之前创建的。

所有系统通用的主**进程**如下图所示。它包括五个阶段:

1.  1.  **聚类选择(或行选择)**:我们选择聚类排序列表的第一行(聚类运行)。特别是，我们采用主题 id 和集群 id。
    2.  **重新排序**:我们对与我们在前一点中选择的集群和主题相关的集合执行传统的检索过程。通过这种方式，我们获得了该主题的聚类中实体的排序列表(使用重新排序的实体运行)。
    3.  **合成**:我们从上一步获得的运行中提取一些实体，并将它们合并到最终的运行中。

对聚类的排序列表中的每个主题的每个前 k 个聚类重复这一过程。

![This image has an empty alt attribute; its file name is comb_sys.png](img/b2a283ab4ec54fb9d9578fc4dc0f3f4f.png)

组合系统的三个版本之间的区别在于我们执行组合阶段的方式，因此我们如何选择实体以及如何将它们插入到最终运行中。

###### **SICO**

在合成阶段，这种方法从相应的重新排序的实体运行中提取固定数量的实体。特别是，我们取了一些具有*分数> 0* 的 *maxEntity* 实体，并按照它们在重新排序的实体运行中出现的相同顺序将它们插入到最终运行中。

如前所述，这是针对特定主题的前 k 个聚类进行的，因此所选择的重新排序的实体运行将每次相对于所选择的聚类和主题 id 而改变。

在下图中，我们报告了这个系统的一个例子。特别地，我们考虑主题 1 的前 2 个集群。我们可以看到，从第一个集群中，我们获得了在顶部运行的重新排序的实体(F、B 和 A)，而从第二个集群中，我们获得了在底部运行的重新排序的实体(E、D 和 C)。从这两次运行中，我们取分数> 0 的第一个 maxEntity=3 个实体(分数未显示，但我们假设大于零)。最后，我们在最后的运行中插入这些实体，保持它们的初始顺序。这样，我们保留了聚类和实体排名。

![This image has an empty alt attribute; its file name is sico.png](img/b996500f7978f28c77ca944f54b97b64.png)

###### SUMCO

在合成阶段，这种方法与 SICO 描述的方法执行相同的过程，但有两处不同。第一个是所有与相同主题相关的实体在被插入到最后一轮之前通过它们的分数排序。第二，在这种重新排序中，我们不使用重新排序的实体的实体分数，而是将包含该实体的聚类的分数添加到它上面。这成为最后一轮的最终得分。

在下图中，我们报告了这个系统的一个例子。关于 SICO，我们注意到的第一个区别是，在两次重新排序的实体运行之间，我们发现了初始的聚类运行。从实体运行中，我们取分数为 0(与 SICO 相同)的第一个 *maxEntity=3* 实体，然后我们将它们所属的集群的实体添加到它们的分数中。因此，对于实体 F、B 和 A，我们添加第一个 top-k 聚类的分数，即 clusterD 而对于实体 E、D 和 C，我们添加第二个 top-k 聚类(clusterA)的分数。最后，我们在最后一轮中插入这些实体，根据它们的分数对它们进行排序。我们可以看到，对于主题 1，EntityF 是位于顶部的一个，因为它的得分较高，而 EntityC 位于底部，因为它的得分最低。

![This image has an empty alt attribute; its file name is sumco.png](img/8aacc8e536567b6b3c04c8f045e33d41.png)

使用这个新的最终得分的想法是创建一个实体的排序列表(最终运行),该列表考虑了集群和实体的相关性。

###### WECO

在合成阶段，这种方法执行与 SUMCO 中描述的过程相同的过程，但最终得分不同。在这种情况下，最终得分计算如下:

*最终得分=(实体得分+聚类得分)*相似度*

其中*相似度*是在聚类平均值和实体嵌入向量之间计算的余弦相似度:*相似度*y*= 1–余弦距离(cluster mean，entityEmbedding)* 。
位于其聚类的平均值附近的实体可能是该聚类的主题所固有的，并且与同一集合中的其他实体高度相关。以这种方式，我们考虑一个实体对于它的集群有多少代表性。对于它们的聚类更有代表性的实体具有最高的分数，然后被认为对于检索目的更重要。

在下图中，我们报告了这个系统的一个例子。

![This image has an empty alt attribute; its file name is weco.png](img/8bf15f57579a2d124c2be675afeb349c.png)

###### 融合系统

我们实施的第二种方法旨在结合组合系统和最新技术的优点。它由四种不同的版本组成。具体而言，它们是:

1.  1.  **私服**
    2.  **索福**
    3.  **乐福**
    4.  **SUMFU**

同样在这里，为了更好地理解实体检索过程，我们首先要给出主要思想的概述，然后再详细介绍该过程。

**想法**:想法是执行最先进的实体检索，然后使用返回的实体排序列表，以便合并来自我们集群的其他相关实体。

所有四个融合版本都依赖于一个通用程序，该程序由以下阶段描述，如下图所示:

1.  1.  **实体选择(或线选择)**:我们选择最先进的运行(经典运行)的第一条线。特别是，我们获取主题 id、实体 id 及其分数。
    2.  **评分条件**:检查实体的评分是否大于流程开始时设置的 *minScore* 。只有当条件满足时，我们才进入下一步。该步骤的目的是从最终运行中排除所有那些具有低分数并因此被认为不是非常相关的实体。
    3.  **基本实体插入**:我们在最终运行中插入在经典运行中选择的实体。
    4.  **等级条件**:我们检查实体的等级是否小于流程开始时设置的 *maxRank* 。只有当条件满足时，我们才进入下一步。该步骤的目的是从最终运行中排除在排序列表中具有较低位置并因此被认为不太相关的所有实体。
    5.  **实体添加**:我们搜索我们正在考虑的实体所属的集群。一旦找到，我们在行选择阶段为我们选择的主题在那个群内的实体上执行传统的检索。在这里，对于传统的检索，我们使用与该聚类相关联的集合(其中一个文档代表一个实体)并获得重新排序的实体运行，来实现在组合系统中描述的相同的过程以进行重新排序。

对实体排序列表中每个主题的前 k 个实体重复这一过程(经典运行)。在这个过程的最后，我们还检查实体的重复并删除它们；事实上，在实体添加阶段，我们会不止一次地插入同一个实体。如果我们看下图，确实，如果例如 EntityA 和 EntityB 属于同一个集群，就会发生这种情况。在这种情况下，它们可能有相同主题的相同相关实体。

![This image has an empty alt attribute; its file name is fus_sys.png](img/b5b2b965d4e993268f4e3a5beb9e04a3.png)

四个版本的融合系统之间的区别在于我们执行实体添加阶段的方式，因此我们如何选择实体以及如何将它们插入到最终运行中。

###### **斯**傅

在实体添加阶段，我们对初始实体所属的集群进行重新排序。从这个列表中，我们选择固定数量的 maxEntity 实体，并按照它们在重新排序的实体运行中出现的相同顺序将它们添加到最终运行中。这样，我们既保留了由最新方法给出的排名，又保留了实体重新排名。



在下图中，我们报告了这个系统的一个例子。特别地，该图表示所选集群的重新排序的实体运行。该集群是经典运行的初始实体所属的集群。从这次运行中，我们取第一个 maxEntity=3 个实体(实体 C、E 和 B ),并在最后一次运行中插入它们，保持它们的初始顺序。

![This image has an empty alt attribute; its file name is sifu.png](img/6da4f5ebadf3ad4291480da1222ee527.png)

###### SOFU

在组合阶段，这种方法执行与 SIFU 中描述的过程相同的过程，只是有所不同。在将实体添加到最后一轮之前，我们收集所有与同一主题相关的实体，并根据分数对它们进行排序。

在下图中，我们报告了这个系统的一个例子。具体来说，该图表示所选集群的重新排序的实体运行。该集群是经典运行的初始实体所属的集群。从这次运行中，我们获取第一个 *maxEntity=3 个*实体(实体 C、E 和 B)。我们将它们与处理经典运行的下一行时获得的具有相同主题的所有其他实体存储在一起。一旦为一个特定的主题收集了所有的实体，我们就在最后的运行中按照它们的分数排序来添加它们。

![This image has an empty alt attribute; its file name is sofu.png](img/fb55f1cc41828dc92c20692c8052a215.png)

###### 乐福

这种方法不同于分数条件阶段的 SOFU。LEFU 实际上并不检查实体的分数是否大于 *maxScore* 阈值，而是检查添加的实体的数量。这样，我们最多为每个主题插入 1000 个实体。



在下图中，我们报告了这个系统的一个例子。特别地，该图表示所选集群的重新排序的实体运行。该集群是经典运行的初始实体所属的集群。从这次运行中，我们取第一个 maxEntity=3 个实体(实体 C、E 和 B)。我们将它们与处理经典运行的下一行时获得的具有相同主题的所有其他实体存储在一起。这组相关实体最多可以包含 1000 个实体。一旦为一个特定的主题收集了所有的实体，我们就在最后的运行中按照它们的分数排序来添加它们。

![This image has an empty alt attribute; its file name is lefu.png](img/e00d427ae764da03cad4d9fee2483553.png)

###### SUMFU

对于实体添加阶段，这种方法不同于 SOFU。和前面的方法一样，SUMFU 为一个特定的主题收集来自重新排序的实体运行的所有实体，并将它们添加到按分数排序的最终运行中。这两种方法之间变化的是最终的分数。对于 SOFU，它只是重新排序的实体的分数，而对于 SUMFU，它是这样计算的:

*final score = classic score*+*entityrenkscore*

其中 *classicScore* 是经典运行的初始实体(在线选择阶段选择的实体)的分数，而*entityrenkscore*是实体在其重新排序的实体运行中的分数。

在下图中，我们报告了这个系统的一个例子。特别地，该图表示所选集群的重新排序的实体运行。该集群是经典运行的初始实体所属的集群。从这次运行中，我们取第一个 maxEntity=3 个实体(实体 C、E 和 B)。我们将它们与处理经典运行的下一行时获得的具有相同主题的所有其他实体存储在一起。对于他们中的每一个，我们如上所述计算新的*最终得分*。一旦收集了特定主题的所有实体，我们就在最后一次运行中按照它们的 *finalScore* 排序添加它们。

![This image has an empty alt attribute; its file name is sumfu.png](img/195d1f6a5d2fad88a667946eb8680f07.png)

// our service

## 不要脸的塞给我们培训和服务！

我提到过我们做[搜索相关性](https://web.archive.org/web/20220930003904/https://sease.io/training/search-relevance-training/search-relevance-training-solr)和[搜索质量评估](https://web.archive.org/web/20220930003904/https://sease.io/training/search-quality-evaluation-trainings/search-quality-evaluation-training)培训吗？如果你想让你的搜索引擎更上一层楼，请联系。

// STAY ALWAYS UP TO DATE

## 订阅我们的时事通讯

你喜欢这篇关于用图形嵌入进行实体搜索的文章吗？不要忘记订阅我们的时事通讯，以便随时了解信息检索世界的最新动态！