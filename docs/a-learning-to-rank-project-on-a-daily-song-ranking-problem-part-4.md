# 每日歌曲排序问题的学习排序项目-第 4 部分

> 原文：<https://web.archive.org/web/sease.io/2021/05/a-learning-to-rank-project-on-a-daily-song-ranking-problem-part-4.html>

你真的以为一切都结束了吗？好消息！
关于每日歌曲排名问题的学习排名项目已有第四集。如果你对将机器学习与搜索相结合感兴趣，在这篇博客文章中，我们将继续探索学习按国家和日期对顶级 k 歌检索进行排序的技术。

和往常一样，为了有一个整体的画面，我建议你看一下以前的剧集，在那里你将学习:
[第 1 部分](https://web.archive.org/web/20221130073030/https://sease.io/2020/12/a-learning-to-rank-project-on-a-daily-song-ranking-problem.html)——如何从可用的数据开始并使用开源库
[建立和构建一个学习分级(LTR)系统第 2 部分](https://web.archive.org/web/20221130073030/https://sease.io/2021/02/a-learning-to-rank-project-on-a-daily-song-ranking-problem-part-2.html)——如何通过使用强大的库 SHAP
[解释模型的行为第 3 部分](https://web.archive.org/web/20221130073030/https://sease.io/2021/03/a-learning-to-rank-project-on-a-daily-song-ranking-problem-part-3.html)——如何创建查询 ID 并在分割训练集和测试集时要小心

在这篇博文中，我将尝试回答以下问题:

1.  1.  **在使用查询级特性创建查询 Id 之后，删除它们有意义吗？**
    2.  **如果我删除欠采样查询会发生什么？**
    3.  **如果我将欠采样查询分组到一个不太细粒度的**query**y Id 中，会发生什么？**

我们开始吧！

###### 问题 1)在使用查询级特征来创建查询 ID 之后移除它们:是或否？

正如在以前的博客文章中已经解释过的，训练集中的每一行都是一个查询-文档对；它由查询级、文档级和潜在的查询文档级特性组成。我们指定“ **query_ID** ”作为每个查询的惟一查询 ID，通过连接所有查询级别的特性(如果可能的话)。

T31

在我们的项目中，查询级别的特性是区域、日、月和工作日。我们使用它们来创建*查询 Id 哈希* ( **query_ID** )，如下表所示:

![](img/dc104a8f57b80fb26cbfb006e23137f7.png)

很自然地想到我们可以删除查询级别的特性，因为该信息已经在查询 Id 中列出。
每个查询 Id 将具有其排序的文档列表，该列表将由查询级特征的相同值组成；那么保留它们的理由是什么呢？

另一方面，通过移除所有查询级特征，在重新排序时，模型将实际上仅依赖于文档级和查询文档级特征来决定如何重新排序文档；正确吗？还是低估？既然查询级别的特性是多余的，我们可以删除它们吗？

我们使用 XGBoost ( **LambdaMART** )训练了一个学习排序模型，并运行了两个不同的测试:

*   *   丢弃所有查询级特征(共 13 个特征)-> 丢弃
    *   保留所有查询级特征(共 17 个特征)-> 保留

【T6

这里获得的结果(表 1):

![](img/15dddd1e127454a1479ed3ae44dda33f.png)

我们可以看到没有很大的区别，但是保留查询级别的特性似乎可以获得更高的性能结果。

为了更好的比较，我们在相同的测试集上测试了它们；为此，训练集和测试集中的功能在数量和名称方面必须相同，否则我们会得到以下错误消息:“*值错误:功能名称不匹配*”。

T3T5

所以在这种情况下，我们没有删除查询级别的特性，而是保留并填充了 **nan** 值；这里举个例子:

![](img/61dcd3a394df7665ef2b729c0bfc580e.png)

只有这样模型才能被训练。获得的结果如下(表 2):

![](img/095180619bdf1c7c193f946cff932843.png)

删除查询级别的特性(DROP-Table 1)或者用' *nan'* '值填充它们没有任何区别。从上表可以看出，无论我们是否在测试集中使用它们，它们都是完全不被考虑的；事实上，结果总是一样的。



另一方面，我们可以注意到，如果我们在训练时保留查询级别的特性，但我们不测试它们，eval-ndcg@10 会在某种程度上受到负面影响(表 3):

![](img/bc786d9b8b9cbcc2442cd45a872646b6.png)

一个原因可能是保留查询级别的特征使模型能够调整其他特征的权重，从而影响树的构建。



还应该指出的是，当处理真实世界的数据时，可能会碰巧有太多的特征，这可能会在对分类特征应用编码技术时导致一些问题。例如，如果使用一次性编码技术，则基数越大的分类要素越多，创建的编码要素也就越多。出于这个原因，我们可能会妥协，只保留最有意义的查询级特性(或者选择其他编码技术)。

###### 问题 2)如果查询 id 采样不足，则丢弃训练样本

评估每个查询 Id 的训练样本的分布是非常重要的，因为我们可能会得到不真实的结果。很少有观察让我们对文件的相关性没有足够的信心。此外，需要避免的两个常见错误是:
–如果我们的观察值数量有限，那么在分割过程中，我们可能会得到一些只有一个训练样本的查询。在这种情况下，查询组的 NDCG@K 将是 1，与模型无关；
–在分割过程中，我们可以将所有带有单一相关性标签的样本放入测试集中。

这就是为什么建议删除欠采样查询的原因。然而，正如已经说过的，这个概念必须结合具体情况。如果我们有可靠的数据，并且我们确信我们已经适当地控制了可能使 NDCG 暴涨的条件(如上所述),我们可以试着保留那些观察结果。

事实上，这就是我们在前面的实现中所做的；我们设置了一个阈值，对于具有低于该阈值的大量观察值的查询 id，我们将这些观察值保存在一个名为 **under_sampled_only_train** 的新数据帧中。这是因为我们将这些观察值保留在训练集中，并且仅当测试集出现的次数少于整个数据集的 20%时，才将其中一些移动到测试集(具有最高数量观察值的查询 id)。为什么采用这种方法？在大多数情况下，训练模型使用更多的数据(因为我们有它！)通常更好；然而，通过这个实验，我们调查并深入了解这是否真的带来了优势。

事实上，我们想知道:如果我们完全删除' **under_sampled_only_train** '观察值，而不是将它们保留在训练集中，会发生什么？

【T8

我们检查了通过保留欠采样查询 id(KEEP)和通过删除它们( DROP )来训练模型之间的差异，然后我们在相同的测试集上测试这些模型(它根本不包含欠采样查询！).这两个模型具有相同的特性(包括查询级特性)，因此可以对它们进行比较；唯一改变的是总观察值的数量，也就是查询 id 的数量。结果总结如下(表 4):

![](img/7c7cd40fa3ea9342a2473ea55c75c4e0.png)

我们可以注意到没有很大的区别。在我们的例子中，将欠采样查询保留在训练集中似乎可以获得相同或略好的结果，因此我们可以非常确定我们拥有可靠的数据，并且性能是真实的。

还应该说，这些结果受到阈值设置的影响；提高或降低阈值，您可以决定在 *under_sampled_only_train* 数据帧中包含更多或更少的观察值，并可能获得不同的性能。
阈值应该根据您的数据分布来设置——尝试不同的值，看看会发生什么！

###### 问题 3)对欠采样查询进行分组

让我们看看另一个实验的结果。

如上所述，在我们的数据集中，有 4 个查询级别的特性(区域、日期、月份和工作日)用于创建查询 Id 散列。欠采样查询存储在名为 **under_sampled_only_train** 的数据帧中，并且只出现在训练集中；这个数据帧包含 252423 个观察值和 3333 个不同的查询 id。
为了使这些查询 Id 组更加“密集”,如果我们只给这些观察值分配一个不太详细的查询 Id，会发生什么情况？

我们尝试了两种不同的方法，每次都“放松”欠采样查询的查询 Id:

1.  1.  将所有具有相同“区域”和“月份”的观察值分组
    2.  将所有具有相同“区域”的观察分组

然后，我们检查了通过对欠采样查询进行分组来训练模型、让它们保持原样以及丢弃它们之间的差异。我们在同一个测试集上测试了这些模型(它根本不包含欠采样查询！).它们具有相同的特性(包括查询级特性),因此可以进行比较；唯一改变的是欠采样查询的查询 id。

我们如何将新的“query_ID”分组并分配给欠采样查询？

###### 1.基于地区和月份的 query_ID

在**under _ sampled _ only _ train**数据帧中，我们有 16 个不同的“区域”值和 12 个不同的“月份”值。我们决定将对于“Region”和“Month”特性具有相同值的所有观察分组，为它们分配一个新的查询 Id:然后我们在 under_sampled_only_train 中获得 144 个唯一的查询 Id(而不是 3333 个):

![](img/eb71abfe057190772ccf2dd2790ca59e.png)

从表中可以看到，对于所有“Region”值等于“ **it** ”且“Month”值等于“ **1** ”的观察值(即 1793)，查询 Id 2226 已被赋值；而查询 Id 2227 已经被分配给具有等于“ **it** ”的“区域”值和等于“ **2** ”的“月份”值的所有观察(即 1408)，等等。

###### 2.仅基于区域的 query_ID

【T8

在**under _ sampled _ only _ train**数据帧中，我们有 16 个不同的“区域”值。我们决定将对“Region”特性具有相同值的所有观察值分组，为它们分配一个新的查询 Id:然后我们在 under_sampled_only_train (i

![](img/efe4f26bae571d354cadc6dcffc19238.png)

从表中可以看到，对于所有“Region”值等于“ **it** 的观测值(即 16799)，查询 Id 2226 已经被赋值；而查询 Id 2227 已经被分配给具有等于“ **nz** ”的“区域”值的所有观察(即 12923)，等等。



**注意:为了避免重复和/或错误，新的查询 id 值不是随机分配给组的，而是我们使用了以下方法:**

```
unique_query_id = under_sampled_only_train['query_ID'].unique().tolist()
unique_region = under_sampled_only_train['Region'].unique().tolist()

column_names = under_sampled_only_train.columns
under_sampled_only_train_grouped = pd.DataFrame(columns=column_names, dtype=int)

i = unique_query_id[0]
for value in unique_region:
    new_dataframe = under_sampled_only_train[under_sampled_only_train['Region'] == value]
    new_dataframe['query_ID'] = i
    under_sampled_only_train_grouped = pd.concat([under_sampled_only_train_grouped, new_dataframe], 
ignore_index=True, sort=False)
    i = i + 1
```

我们已经从两个列表中的 *under_sampled_only_train* 数据帧中获得了唯一的“区域”值和唯一的“查询 Id”值，然后将前 16 个唯一的查询 ID 值作为新的“查询 ID”分配给每个特定的“区域”组。

这种选择是为了对仍然具有部分共同用户请求的行进行分组(即区域或区域和月份)，从而创建具有比以前更通用的查询和更多观察的组。

这里的模特训练表演(表 5):

![](img/b005cb5c5d69366474cda92eb4f1e654.png)

第一个和第四个“场景”与问题 2 中描述的相同，而第二个和第三个是在对训练集中的欠采样查询进行分组之后获得的结果。结果或多或少是相同的，但似乎保留或删除欠采样查询比将它们分组到一个不太细粒度的查询 Id 中要好。
然而，如果我们决定对这些观察进行分组，以使查询 Id 的列表更加“填充”，那么最好使用尽可能多的查询级特性，这可能会带来一些小的改进。

## 最终考虑

1.  1.  如果可能的话，最好是**在数据集**中保留所有查询级别的特征，尽管它们已经用于创建查询 Id。即使上面没有报道，这一点在问题 2 和问题 3 的实施过程中也得到了验证，我们在保持它们的时候总是得到最好的模型性能。
    2.  如果您有可靠的数据，并且确信您已经正确处理了可能导致 NDCG 暴涨的情况，您可以尝试**将欠采样查询**保留在训练集中，看看它是否有所改进。记得根据您的数据分布设置阈值！
    3.  最好尽可能准确地使用查询 id 来训练模型；如果您的查询只有很少的观察值，那么您可以通过稍微“放宽”查询 Id 的粒度来尝试对它们进行分组，从而包含更少的查询级特性。

// our service

## 不要脸的塞给我们培训和服务！

我提到过我们做[学习排名](https://web.archive.org/web/20221130073030/https://sease.io/learning-to-rank-training)和[搜索相关性](https://web.archive.org/web/20221130073030/https://sease.io/training/search-relevance-training/search-relevance-training-solr)培训吗？
我们还提供关于这些主题的咨询，[如果您想让您的搜索引擎更上一层楼，请联系](https://web.archive.org/web/20221130073030/https://sease.io/contacts)！

// STAY ALWAYS UP TO DATE

## 订阅我们的时事通讯

你喜欢这个帖子吗？这个帖子是关于一个关于每日歌曲排名问题的学习排名项目。不要忘记订阅我们的时事通讯，以便随时了解信息检索世界的最新动态！