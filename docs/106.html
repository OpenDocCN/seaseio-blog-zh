<html>
<head>
<title>Impact of Large Stored fields on Apache Solr Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型存储字段对Apache Solr查询性能的影响</h1>
<blockquote>原文：<a href="https://web.archive.org/web/sease.io/2022/12/impact-of-large-stored-fields-on-apache-solr-query-performance.html#0001-01-01">https://web.archive.org/web/sease.io/2022/12/impact-of-large-stored-fields-on-apache-solr-query-performance.html#0001-01-01</a></blockquote>
									<section class="elementor-section elementor-top-section elementor-element elementor-element-425a524f ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="425a524f" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-7a80996 ot-flex-column-vertical" data-id="7a80996" data-element_type="column">
			<div class="elementor-column-wrap">
							<div class="elementor-widget-wrap">
								</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-90a7a4c ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="90a7a4c" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-e04327d ot-flex-column-vertical" data-id="e04327d" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-3c375c7 elementor-widget elementor-widget-iheading" data-id="3c375c7" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h2 class="main-heading translated">Solr中存储的字段</h2>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-93c14be elementor-widget elementor-widget-text-editor" data-id="93c14be" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">在Solr中，字段可以设置为索引和/或存储。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-438ec0d elementor-widget elementor-widget-text-editor" data-id="438ec0d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<pre class="wp-block-code"><code>&lt;field name="field" type="text" indexed="true" stored="true" /&gt;</code></pre>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fe33b6b elementor-widget elementor-widget-text-editor" data-id="fe33b6b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<ul>
<li class="translated"><strong>索引</strong>:如果设置为true，则该字段可用于搜索。</li>
<li class="translated"><strong>存储</strong>:如果设置为真，字段值也存储在solr中。以下是一些用法示例:</li>
</ul>
<ol>
<li class="translated">在查询时检索字段值</li>
<li class="translated">部分更新(稍后将在博客中介绍)</li>
<li class="translated">突出</li>
</ol>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8f77cd5 elementor-widget elementor-widget-text-editor" data-id="8f77cd5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">存储字段在几种情况下会很有帮助。缺点是它们的使用会增加索引的大小，并且会影响性能，这取决于它们的使用方式。</p>
<p class="translated">在某些情况下，字段可能很长。想象一下一本电子书:它可以轻松达到相当大的兆字节。</p>
<p class="translated">在索引时，可以通过文本分析来建模和优化倒排索引的形状(例如，停用词过滤、同义词折叠)；此外，请记住，倒排索引中的字典会对所摄取的术语执行隐式重复数据删除:如果输入的电子书包含1000次术语检索，那么索引将只有一个条目。</p>
<p class="translated">但是，以上所有内容仅对索引字段有效，这些字段的内容构成了倒排索引。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-19983c0 elementor-widget elementor-widget-iheading" data-id="19983c0" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h6 class="main-heading translated">存储字段呢？</h6>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-e27e4bb elementor-widget elementor-widget-text-editor" data-id="e27e4bb" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">一个完全不同的行为:存储字段逐字保存在持久数据结构中:文本压缩在这里起着至关重要的作用，尤其是对于长文本，但关键是:在数据检索时，对于给定的存储字段，搜索引擎必须返回在索引时插入的准确的文字值。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-192368f elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="192368f" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-f09213a ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="f09213a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-6ce648b ot-flex-column-vertical" data-id="6ce648b" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-7c07965 elementor-widget elementor-widget-iheading" data-id="7c07965" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h2 class="main-heading translated">案例研究:巨大的存储场</h2>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-54d2be8 elementor-widget elementor-widget-text-editor" data-id="54d2be8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">客户搜索基础设施包括一个关系数据库和SolrCloud 6.1。</p>
<p class="translated">作为增量改进路径的一部分，一组变更请求需要启用部分更新[ <a href="https://web.archive.org/web/20221223104504/https://solr.apache.org/guide/8_11/updating-parts-of-documents.html"> 1 </a> ]功能。</p>
<p class="translated">部分更新只允许更新已经索引的solr文档中的字段子集，而不需要提交整个文档。</p>
<p class="translated">使用这种特性的前提条件是模式中的所有字段都必须是stored (stored="true ")或doc values(doc values = " true ")；唯一的例外与作为copyField指令目标的字段有关，这些字段必须设置为stored="false "。</p>
<p class="translated">为了更新文档，solr必须删除旧版本并用更新的信息索引新文档。通过部分更新，solr能够使用存储字段的信息来索引文档中未更改的字段。通过这种方式，用户可以只发送已经更新的字段(例如元数据或一些小的内容)。这将大大减少用户要传输的数据量，唯一要付出的代价是索引大小的增加。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c0c899c elementor-widget elementor-widget-iheading" data-id="c0c899c" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h6 class="main-heading translated">问题:查询性能下降</h6>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-e35dc51 elementor-widget elementor-widget-text-editor" data-id="e35dc51" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">将所有字段设置为存储后，查询性能变得更差。我们将平均查询时间从10毫秒缩短到了500毫秒。</p>
<p class="translated">乍一看，这似乎是一个奇怪的副作用，甚至与刚刚启用的部分更新功能无关(我们认为是这样的):后面没有索引，慢速查询的结构非常简单。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f429612 elementor-widget elementor-widget-html" data-id="f429612" data-element_type="widget" data-widget_type="html.default">
				<div class="elementor-widget-container">
			<pre>q=something&amp;fl;=id,first_name,surname,age,email_address</pre>
		</div>
				</div>
				<div class="elementor-element elementor-element-4124043 elementor-widget elementor-widget-text-editor" data-id="4124043" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">在查询时，存储字段在数据检索阶段起着至关重要的作用，但是正如您从上面的查询中所看到的，我们只要求其中的一些字段。此外，姓名和电子邮件地址是平均长度较短的字段。</p>
<p class="translated">此外，声明要返回的字段在我们更改之前就已经存储了。</p>
<p class="translated">然后发生了什么？</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-83b9ef0 elementor-widget elementor-widget-iheading" data-id="83b9ef0" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h6 class="main-heading translated">字段检索如何工作</h6>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-7246084 elementor-widget elementor-widget-text-editor" data-id="7246084" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">在对Solr内部进行深入研究后，我们发现查询性能下降是由于Solr存储字段的检索方式。</p>
<p class="translated">下面是实现该检索逻辑的方法:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-676dfbf elementor-widget elementor-widget-html" data-id="676dfbf" data-element_type="widget" data-widget_type="html.default">
				<div class="elementor-widget-container">
			<pre>public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {

    final SerializedDocument doc = document(docID);

    for (int fieldIDX = 0; fieldIDX &lt; doc.numStoredFields; fieldIDX++) {
      final long infoAndBits = doc.in.readVLong();
      final int fieldNumber = (int) (infoAndBits &gt;&gt;&gt; TYPE_BITS);
      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldNumber);

      final int bits = (int) (infoAndBits &amp; TYPE_MASK);
      assert bits &lt;= NUMERIC_DOUBLE : "bits=" + Integer.toHexString(bits);

      switch (visitor.needsField(fieldInfo)) {
        case YES:
          readField(doc.in, visitor, fieldInfo, bits);
          break;
        case NO:
          if (fieldIDX == doc.numStoredFields - 1) { 
            return;
          }
          skipField(doc.in, bits);
          break;
        case STOP:
          return;
      }
    }
  }</pre>		</div>
				</div>
				<div class="elementor-element elementor-element-7ae016b elementor-widget elementor-widget-text-editor" data-id="7ae016b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">该方法迭代所有存储的字段；它<strong>跳过</strong>不需要的字段，而<strong>只保留</strong>客户要求的字段。当光标在最后一个字段上时，如果它没有被请求，过程结束，因为不需要跳过(记住，我们在最后一个字段上)。</p>
<p class="translated">您可以将文档中存储的字段想象成一个长数组，其中字段一个接一个地编码。每个字段在前面提供一些元数据(例如，字段信息、长度)，允许访问者阅读或跳过它。如果我们想得到位置n的字段，我们必须遍历从0到n-1的所有字段(读取或跳过它们)。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-29d8628 elementor-widget elementor-widget-image" data-id="29d8628" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img data-attachment-id="45221" data-permalink="https://web.archive.org/web/20221223104504/https://sease.io/2022/12/impact-of-large-stored-fields-on-apache-solr-query-performance.html/untitled-diagram-drawio" data-orig-file="https://web.archive.org/web/20221223104504/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?fit=561%2C81&amp;ssl=1" data-orig-size="561,81" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Untitled-Diagram.drawio" data-image-description="" data-image-caption="" data-medium-file="https://web.archive.org/web/20221223104504/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?fit=300%2C43&amp;ssl=1" data-large-file="https://web.archive.org/web/20221223104504/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?fit=561%2C81&amp;ssl=1" decoding="async" width="561" height="81" src="../Images/d2b0659b8b9270739e687c7f8785d693.png" class="attachment-large size-large wp-image-45221" alt="" loading="lazy" srcset="https://web.archive.org/web/20221223104504im_/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?w=561&amp;ssl=1 561w, https://web.archive.org/web/20221223104504im_/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?resize=300%2C43&amp;ssl=1 300w" sizes="(max-width: 561px) 100vw, 561px" data-original-src="https://web.archive.org/web/20221223104504im_/https://i0.wp.com/sease.io/wp-content/uploads/2022/01/Untitled-Diagram.drawio.png?fit=561%2C81&amp;ssl=1"/>														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d7f0230 elementor-widget elementor-widget-text-editor" data-id="d7f0230" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">读取一个字段值比跳过它代价更大。然而，跳过一个字段并不是免费的。从CPU的角度来看，这是一个恒定时间的操作，但从内存访问的角度来看，情况有所不同。当按顺序访问数据时，CPU会在实际读取数据之前预取缓存中的数据。</p>
<p class="translated">举个简单的例子:如果读取数据块X，数据块X+1会在缓存中预取，因为在读取X之后，可能会需要X+1。将这一概念应用于我们读取存储字段的情况，通过跳过存储字段进行读取来遍历存储字段是一种快速操作，因为连续的块是连续预取的。每当光标移动到下一个字段时，数据已经在缓存中，等待数据移动到CPU缓存没有延迟。</p>
<p class="translated">现在，如果其中一个场非常大，会发生什么？(大于一个缓存块)。预取机制不能理解要预取哪个块(属于要读取的下一个字段的块),并且当光标在跳过之后到达那里时，必须停止执行，以等待正确的块被加载到CPU缓存中。这会导致执行延迟。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ceb9c6c elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="ceb9c6c" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-40e5da2 ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="40e5da2" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-edb58f4 ot-flex-column-vertical" data-id="edb58f4" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-bb8c65a elementor-widget elementor-widget-iheading" data-id="bb8c65a" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h2 class="main-heading translated">SOLR 6.5优化</h2>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-76a84a6 elementor-widget elementor-widget-text-editor" data-id="76a84a6" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated"><strong> Solr 6.5 </strong>这里介绍一个重要的优化(<a href="https://web.archive.org/web/20221223104504/https://issues.apache.org/jira/browse/SOLR-10273" data-bcup-haslogintext="no"> SOLR-10273 </a>)。<br/>该优化消除了由于跳过字段列表中没有请求的大字段而导致的开销。变化在于在索引时移动存储字段数组末尾的最大字段。</p>
<p class="translated"><strong> N.B </strong>:除了最后一个字段(如果不需要)，所有字段都被读取或跳过。最后一个字段不需要任何跳过。因此，如果大字段是最后一个，就没有开销，因为根本没有跳过。</p>
<p class="translated">问题解决了？或多或少。</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-43fb51e elementor-widget elementor-widget-iheading" data-id="43fb51e" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        <h6 class="main-heading translated">不止一个大领域？</h6>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-d31c5ba elementor-widget elementor-widget-text-editor" data-id="d31c5ba" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">虽然在一个文档中最多有一个大字段是很常见的，但是如果有多个大字段，会发生什么情况呢？不幸的是，这种情况不是由<a href="https://web.archive.org/web/20221223104504/http://solr-10273/"> SOLR- </a> <a href="https://web.archive.org/web/20221223104504/https://issues.apache.org/jira/browse/SOLR-10273"> 10273 </a>中介绍的优化来管理的。</p>
<p class="translated">如果有多个大的存储字段，那么在查询时性能会有所下降。唯一可能的建议是使用<strong> docValues </strong>来设计模式以避免这种情况。</p>
<p class="translated">让我们回到上面的方法:只有当客户机请求至少一个存储字段时，才执行这个方法。</p>
<p class="translated">出于这个原因，如果客户端只要求<strong>也是<strong>文档值</strong>的字段</strong>，Solr根本不能访问存储的结构。因此，上面的检索工作流不适用。</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-76ede9c ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="76ede9c" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-d5162c7 ot-flex-column-vertical" data-id="d5162c7" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-d0fa27a elementor-widget elementor-widget-iheading" data-id="d0fa27a" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        	            <span>// links and references</span>
	        	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-ab175ba elementor-widget elementor-widget-text-editor" data-id="ab175ba" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">以下是文档值字段的一些参考:</p>
<ul>
<li class="translated"><a href="https://web.archive.org/web/20221223104504/https://solr.apache.org/guide/8_9/docvalues.html"> Apache Solr文档价值指南</a></li>
<li class="translated"><a href="https://web.archive.org/web/20221223104504/https://sease.io/2020/03/docvalues-vs-stored-fields-apache-solr-features-and-performance-smackdown.html">文档值与存储字段、Apache Solr特性和性能对比</a></li>
</ul>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-6bd42c0a ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="6bd42c0a" data-element_type="section" data-settings="{&quot;background_background&quot;:&quot;classic&quot;}">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1944a024 ot-flex-column-vertical" data-id="1944a024" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-667554c elementor-widget elementor-widget-iheading" data-id="667554c" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        	            <span>// our services</span>
	        <h2 class="main-heading translated">不要脸的塞给我们培训和服务！</h2>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-3987122e elementor-widget elementor-widget-text-editor" data-id="3987122e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">我提到过我们做<a href="https://web.archive.org/web/20221223104504/https://sease.io/training/apache-solr-training">阿帕奇Solr </a>培训吗？我们也提供这些主题的咨询，<a href="https://web.archive.org/web/20221223104504/https://sease.io/contacts">如果你想让你的搜索引擎更上一层楼，请联系</a>！</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
				<section class="elementor-section elementor-top-section elementor-element elementor-element-29019f00 ot-traditional elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="29019f00" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-2f2fc0c6 ot-flex-column-vertical" data-id="2f2fc0c6" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-581d6ae0 elementor-widget elementor-widget-iheading" data-id="581d6ae0" data-element_type="widget" data-widget_type="iheading.default">
				<div class="elementor-widget-container">
					<div class="ot-heading">
	        	            <span>// STAY ALWAYS UP TO DATE</span>
	        <h2 class="main-heading translated">订阅我们的时事通讯</h2>	    </div>
	    		</div>
				</div>
				<div class="elementor-element elementor-element-3a994bee elementor-widget elementor-widget-text-editor" data-id="3a994bee" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p class="translated">你喜欢这篇关于大型存储字段对Apache Solr查询性能的影响的文章吗？不要忘记订阅我们的时事通讯，以便随时了解信息检索世界的最新动态！</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7fb22f57 elementor-widget elementor-widget-wp-widget-mc4wp_form_widget" data-id="7fb22f57" data-element_type="widget" data-widget_type="wp-widget-mc4wp_form_widget.default">
				<div class="elementor-widget-container">
			<script>(function() {
	window.mc4wp = window.mc4wp || {
		listeners: [],
		forms: {
			on: function(evt, cb) {
				window.mc4wp.listeners.push(
					{
						event   : evt,
						callback: cb
					}
				);
			}
		}
	}
})();
</script><!-- Mailchimp for WordPress v4.8.12 - https://wordpress.org/plugins/mailchimp-for-wp/ --><form id="mc4wp-form-1" class="mc4wp-form mc4wp-form-1343" method="post" data-id="1343" data-name="Sease Mailchimp"><div class="mc4wp-form-fields">
<div class="subscribe-inner-form">
	<input type="email" name="EMAIL" placeholder="Your Email" required=""/>
	<button type="submit" class="subscribe-btn-icon"><i class="flaticon-telegram"/></button>
</div>	

<p class="translated"><label> <input name="AGREE_TO_TERMS" type="checkbox" value="1" required=""/> <a href="https://web.archive.org/web/20221223104504/https://sease.io/privacy-policy" target="_blank">我已经阅读并同意隐私政策</a> </label></p></div><label style="display: none !important;">Leave this field empty if you're human: <input type="text" name="_mc4wp_honeypot" value="" tabindex="-1" autocomplete="off"/></label><input type="hidden" name="_mc4wp_timestamp" value="1671792305"/><input type="hidden" name="_mc4wp_form_id" value="1343"/><input type="hidden" name="_mc4wp_form_element_id" value="mc4wp-form-1"/><div class="mc4wp-response"/></form><!-- / Mailchimp for WordPress Plugin -->		</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									    
</body>
</html>